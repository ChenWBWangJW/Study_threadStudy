test_3_20.cpp
/****************************************
*要求：
*	批量创建线程
*详解：
*	定义5个线程对象，通过将初始化构造函数
*	的返回值赋值给他们。该方法所创建线程都
*	是可连接线程，因此要用函数join来等待他
*	们结束，可以发现每次打印顺序并不一致是
*	因为CPU线程调度的随机性。
*****************************************/


test_3_21.cpp
/****************************************
*要求：
*	创建一个不传参数的线程
*详解：
*	首先定义一个线程对象，定义对象后马上
*	启动线程，然后主线程休眠1秒，这样就
* 保证了子线程能够执行完毕，然后主线程
* 退出，子线程也会退出，预防主线程过早
* 退出导致子线程没有机会执行
*****************************************/


test_3_22.cpp
/****************************************
*要求：
*	创建一个线程并传入整型参数
*详解：
*	创建线程时，把一个整型作为参数传给构造
*	函数，然后在线程函数中打印出来，并且使
*	用join()等待线程结束，函数join()会一直等
*	到子线程结束才返回并执行该函数后面的代
*	码
*****************************************/


test_3_23.cpp
/****************************************
*要求：
*	创建一个线程，并传递字符串作为参数
*详解：
*	无
*****************************************/


test_3_24.cpp
/****************************************
*要求：
*	创建一个线程，并传递结构体作为参数
*详解：
*	通过结构体传递多个值给线程函数
*****************************************/


test_3_25.cpp
/****************************************
*要求：
*	创建一个线程，传多个参数给线程函数
*详解：
*	传入多个参数给构造函数，同时线程函数也
*	要准备好同样多的形参，通过对整形地址&k
*	的引用，在线程中修改了他所指向的变量的
*	内容，所以在主线程中k的值也被修改了
*****************************************/


test_3_26
/****************************************
*要求：
*	把可连接线程转为分离线程(C++11&POSIX)
*详解：
*	我们调用detach()来分离线程，这样主线程
*	就可以不用等待子线程结束而可以自己先结
*	束。我们调用了pthead_exit(NULL)来结束
* 	主线程，这样主线程就会等待子线程结束后
* 	再结束。值得一提的时，他会先打印主线程
*	的k变量，是因为线程还没进行切换。
*****************************************/


test_3_27
/****************************************
*要求：
*	通过移动构造函数来启动线程
*详解：
*	通过将对象t1转换为右值引用类型后进行调
*	用，从而实现移动语义，即将t1的资源所有
*	权转移给t2，从而实现通过移动构造函数来
*	启动线程
*****************************************/
